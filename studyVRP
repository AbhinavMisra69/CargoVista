struct City {
    int id;
    string name;
    int x, y;
    City(){}

    City(int id, const string& name, int x, int y)
        : id(id), name(name), x(x), y(y) {}
};

struct PPCarrier {
    double capacity = 6000;
    double load = 0;
    int depotID;
    vector<int> route; // sequence of PPCity indices
};


double RouteCost(const vector<int>& route, const vector<PPCity>& nodes, const PPCity& depot) {
    if (route.empty()) return 0;
    double cost = 0.0;
    cost += distBtwCities[depot.id][nodes[route.front()].id];
    for (int i = 0; i < route.size() - 1; ++i)
        cost += distBtwCities[nodes[route[i]].id][nodes[route[i+1]].id];
    cost += distBtwCities[nodes[route.back()].id][depot.id];
    return cost;
}

double TotalCost(const vector<PPCarrier>& vehicles, const vector<PPCity>& nodes, const unordered_map<int, PPCity>& depotMap) {
    double total = 0.0;
    for (const auto& v : vehicles)
        total += RouteCost(v.route, nodes, depotMap.at(v.depotID));
    return total;
}

// Initial solution: assign each order to the first vehicle that fits
vector<PPCarrier> CreateInitialSolution(const vector<PPCity>& nodes,
                                        const vector<pair<int, int>>& pdPairs,
                                        const vector<PPCity>& depots,
                                        int vehiclesPerDepot) {
    unordered_map<int, PPCity> depotMap;
    for (const auto& d : depots)
        depotMap[d.id] = d;

    vector<PPCarrier> vehicles;
    for (const auto& depot : depots) {
        for (int i = 0; i < vehiclesPerDepot; ++i) {
            PPCarrier v;
            v.capacity = 6000;
            v.load = 0;
            v.depotID = depot.id;
            vehicles.push_back(v);
        }
    }

    unordered_set<int> assignedOrders;

    for (const auto& pair : pdPairs) {
        int pid = pair.first;
        int did = pair.second;

        int orderId = nodes[pid].orderId;
        if (assignedOrders.count(orderId)) continue; // Already assigned

        double weight = nodes[pid].supply;

        bool assigned = false;
        for (auto& v : vehicles) {
            if (v.load + weight <= v.capacity) {
                v.route.push_back(pid);
                v.route.push_back(did);
                v.load += weight;
                assignedOrders.insert(orderId);
                assigned = true;
                break;
            }
        }

        // Optional: handle unassigned orders (e.g., log them)
        if (!assigned) {
            cerr << "Warning: Order " << orderId << " could not be assigned to any vehicle.\n";
        }
    }

    return vehicles;
}


// Validate route constraints: pickup before delivery, capacity not exceeded
bool IsValidRoute(const vector<int>& route, const vector<PPCity>& nodes, double capacity) {
    unordered_map<int, bool> pickedUp;
    double load = 0;

    for (int idx : route) {
        const PPCity& n = nodes[idx];
        if (n.isPickup) {
            load += n.supply;
            pickedUp[n.orderId] = true;
        } else {
            if (!pickedUp[n.orderId]) return false;
            load -= n.demand;
        }
        if (load > capacity) return false;
    }
    return true;
}

// Neighborhood: swap two full order pairs (pickup-delivery pair)
void SwapOrders(vector<PPCarrier>& vehicles, const vector<pair<int, int>>& pdPairs) {
    int maxAttempts = 100;
    while (maxAttempts--) {
        int v1 = rand() % vehicles.size();
        int v2 = rand() % vehicles.size();
        if (vehicles[v1].route.size() < 2 || vehicles[v2].route.size() < 2) continue;

        int i = rand() % pdPairs.size();
        int pid1 = pdPairs[i].first;
        int did1 = pdPairs[i].second;

        int j = rand() % pdPairs.size();
        if (i == j) continue; // Avoid self-swap

        int pid2 = pdPairs[j].first;
        int did2 = pdPairs[j].second;

        auto& r1 = vehicles[v1].route;
        auto& r2 = vehicles[v2].route;

        // Remove both pid1, did1 from r1
        r1.erase(remove(r1.begin(), r1.end(), pid1), r1.end());
        r1.erase(remove(r1.begin(), r1.end(), did1), r1.end());

        // Remove both pid2, did2 from r2
        r2.erase(remove(r2.begin(), r2.end(), pid2), r2.end());
        r2.erase(remove(r2.begin(), r2.end(), did2), r2.end());

        // Insert the new orders at the end
        r1.push_back(pid2);
        r1.push_back(did2);

        r2.push_back(pid1);
        r2.push_back(did1);

        return;
    }
}

vector<PPCarrier> SimulatedAnnealingVRP(vector<PPCity>& nodes, vector<pair<int,int>>& pdPairs, vector<PPCity> depots, int vehiclesPerDepot) {
    unordered_map<int, PPCity> depotMap;
    for (auto& d : depots)
        depotMap[d.id] = d;

    vector<PPCarrier> current = CreateInitialSolution(nodes, pdPairs, depots, vehiclesPerDepot);
    vector<PPCarrier> best = current;
    double bestCost = TotalCost(best, nodes, depotMap);
    double temp = 1000.0, cooling = 0.995;
    int maxIter = 10000;

    srand(time(0));

    for (int iter = 0; iter < maxIter; ++iter) {
        vector<PPCarrier> neighbor = current;
        SwapOrders(neighbor, pdPairs);

        bool valid = true;
        for (auto& v : neighbor)
            if (!IsValidRoute(v.route, nodes, v.capacity)) valid = false;
        if (!valid) continue;

        double newCost = TotalCost(neighbor, nodes, depotMap);
        double delta = newCost - bestCost;

        if (delta < 0 || ((double)rand() / RAND_MAX) < exp(-delta / temp)) {
            current = neighbor;
            if (newCost < bestCost) {
                best = neighbor;
                bestCost = newCost;
            }
        }
        temp *= cooling;
    }
    return best;
}

vector<PPCity> depots;
    for (City hub : hubs) {
        depots.push_back(PPCity(hub.id, 0, 0));
    }

 vector<PPCity> nodes;
vector<pair<int, int>> pdPairs;

for (auto& order : simulatedOrders) {
    int pickupIdx = nodes.size();
    nodes.push_back(PPCity(order.source, 0, order.weight, order.orderId, true));

    int deliveryIdx = nodes.size();
    nodes.push_back(PPCity(order.destination, order.weight, 0, order.orderId, false));

    pdPairs.push_back({pickupIdx, deliveryIdx});
}


    // Simulated Annealing to find the optimal routes
    int vehiclesPerDepot = 2;
    vector<PPCarrier> bestSolution = SimulatedAnnealingVRP(nodes, pdPairs, depots, vehiclesPerDepot);

    // Output the routes
    for (int v = 0; v < bestSolution.size(); ++v) {
        cout << "Vehicle " << v << " (Depot " << bestSolution[v].depotID << "): ";
        for (int i = 0; i < bestSolution[v].route.size(); ++i) {
            cout << nodes[bestSolution[v].route[i]].id;
            if (i < bestSolution[v].route.size() - 1)
                cout << " -> ";
        }
        cout << endl;
    }

}
