#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <limits>
#include <algorithm>

using namespace std;

struct Order {
    int id;
    int destination; // city id
    double weight;
};

struct City {
    int id;
};

struct CarrierRoute {
    int hubId;
    vector<int> route;
    double totalWeight;
    double totalDistance;
};

struct OrderWithPriority {
    Order order;
    int priority;
    bool operator<(const OrderWithPriority& other) const {
        return priority < other.priority; // Max-heap: higher priority first
    }
};

// Dijkstra's Algorithm using adjacency matrix
vector<int> shortestPath(int src, int dest, const vector<vector<double>>& adj_matrix) {
    int n = adj_matrix.size();
    vector<double> dist(n, numeric_limits<double>::infinity());
    vector<int> prev(n, -1);
    vector<bool> visited(n, false);
    priority_queue<pair<double, int>, vector<pair<double, int>>, greater<>> pq;

    dist[src] = 0;
    pq.push({0.0, src});

    while (!pq.empty()) {
        auto [currDist, u] = pq.top(); pq.pop();
        if (visited[u]) continue;
        visited[u] = true;

        for (int v = 0; v < n; ++v) {
            if (adj_matrix[u][v] > 0 && !visited[v]) {
                double alt = dist[u] + adj_matrix[u][v];
                if (alt < dist[v]) {
                    dist[v] = alt;
                    prev[v] = u;
                    pq.push({alt, v});
                }
            }
        }
    }

    vector<int> path;
    for (int at = dest; at != -1; at = prev[at])
        path.push_back(at);
    reverse(path.begin(), path.end());
    return path;
}

CarrierRoute PriorityBasedCarrierRoute(const vector<Order>& orders,
                                       const unordered_map<int, int>& orderPriority,
                                       const unordered_map<int, City>& cityMap,
                                       const City& sellerLocation,
                                       const vector<vector<double>>& adj_matrix,
                                       int hubId,
                                       double vehicleCapacity) {
    priority_queue<OrderWithPriority> pq;
    unordered_map<int, vector<Order>> ordersByCity;
    unordered_set<int> deliveredOrderIds;

    for (const auto& order : orders) {
        if (order.weight > vehicleCapacity) continue; // skip overweight orders
        int pri = orderPriority.at(order.id);
        pq.push({order, pri});
        ordersByCity[order.destination].push_back(order);
    }

    CarrierRoute cr;
    cr.hubId = hubId;
    cr.route.push_back(sellerLocation.id);
    cr.totalWeight = 0;
    cr.totalDistance = 0.0;
    int currentCity = sellerLocation.id;

    while (!pq.empty()) {
        double currentLoad = 0.0;
        int startCity = currentCity;

        while (!pq.empty()) {
            OrderWithPriority next;
            do {
                if (pq.empty()) break;
                next = pq.top(); pq.pop();
            } while (deliveredOrderIds.count(next.order.id));

            if (deliveredOrderIds.count(next.order.id)) break;
            if (currentLoad + next.order.weight > vehicleCapacity) {
                pq.push(next); // Put back for next round
                break;
            }

            vector<int> path = shortestPath(currentCity, next.order.destination, adj_matrix);

            for (size_t i = 1; i < path.size(); ++i) {
                int prevCity = path[i - 1];
                int thisCity = path[i];
                cr.totalDistance += adj_matrix[prevCity][thisCity];

                if (!ordersByCity.count(thisCity)) continue;
                for (const auto& o : ordersByCity[thisCity]) {
                    if (!deliveredOrderIds.count(o.id) && currentLoad + o.weight <= vehicleCapacity) {
                        deliveredOrderIds.insert(o.id);
                        currentLoad += o.weight;
                        cr.totalWeight += o.weight;
                        cr.route.push_back(thisCity);
                    }
                }
                ordersByCity[thisCity].erase(remove_if(ordersByCity[thisCity].begin(), ordersByCity[thisCity].end(),
                                                       [&](const Order& o) { return deliveredOrderIds.count(o.id); }),
                                             ordersByCity[thisCity].end());
            }

            currentCity = next.order.destination;
        }

        // Return to seller location for next batch
        if (!pq.empty()) {
            vector<int> returnPath = shortestPath(currentCity, sellerLocation.id, adj_matrix);
            for (size_t i = 1; i < returnPath.size(); ++i) {
                int prevCity = returnPath[i - 1];
                int thisCity = returnPath[i];
                cr.totalDistance += adj_matrix[prevCity][thisCity];
                cr.route.push_back(thisCity);
            }
            currentCity = sellerLocation.id;
        }
    }

    return cr;
}
