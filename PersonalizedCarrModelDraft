#include <iostream>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <queue>
#include <algorithm>
#include <limits>

using namespace std;

struct Order {
    int id;
    int destinationCityId;
};

struct City {
    int id;
    vector<pair<int, double>> neighbors; // destination city id and distance
};

struct OrderWithPriority {
    Order order;
    int priority;

    bool operator<(const OrderWithPriority& other) const {
        return priority < other.priority; // higher priority comes first in max heap
    }
};

vector<int> shortestPath(int fromCityId, int toCityId, const unordered_map<int, City>& cityMap) {
    unordered_map<int, double> dist;
    unordered_map<int, int> prev;
    for (const auto& [id, _] : cityMap) {
        dist[id] = numeric_limits<double>::infinity();
    }
    dist[fromCityId] = 0.0;

    using PD = pair<double, int>; // (distance, cityId)
    priority_queue<PD, vector<PD>, greater<PD>> pq;
    pq.push({0.0, fromCityId});

    while (!pq.empty()) {
        auto [currDist, u] = pq.top(); pq.pop();
        if (u == toCityId) break;
        if (currDist > dist[u]) continue;

        for (const auto& [v, weight] : cityMap.at(u).neighbors) {
            if (dist[u] + weight < dist[v]) {
                dist[v] = dist[u] + weight;
                prev[v] = u;
                pq.push({dist[v], v});
            }
        }
    }

    vector<int> path;
    for (int at = toCityId; prev.count(at); at = prev[at]) {
        path.push_back(at);
    }
    path.push_back(fromCityId);
    reverse(path.begin(), path.end());
    return path;
}

vector<int> PriorityBasedDelivery(
    const vector<Order>& orders,
    const unordered_map<int, int>& orderPriorityMap,
    const unordered_map<int, City>& cityMap,
    int sellerCityId
) {
    priority_queue<OrderWithPriority> pq;
    unordered_map<int, vector<int>> cityToOrdersMap; // cityId -> order IDs
    unordered_map<int, Order> orderMap;
    unordered_set<int> deliveredOrderIds;

    for (const auto& order : orders) {
        int priority = orderPriorityMap.at(order.id);
        pq.push({order, priority});
        orderMap[order.id] = order;
        cityToOrdersMap[order.destinationCityId].push_back(order.id);
    }

    vector<int> deliverySequence;
    int currentCityId = sellerCityId;

    while (!pq.empty()) {
        OrderWithPriority next;
        do {
            if (pq.empty()) break;
            next = pq.top(); pq.pop();
        } while (deliveredOrderIds.count(next.order.id));

        if (deliveredOrderIds.count(next.order.id)) break;

        vector<int> path = shortestPath(currentCityId, next.order.destinationCityId, cityMap);
        for (int cityId : path) {
            if (cityToOrdersMap.count(cityId)) {
                vector<int>& ids = cityToOrdersMap[cityId];
                vector<int> remaining;
                for (int id : ids) {
                    if (!deliveredOrderIds.count(id)) {
                        deliveredOrderIds.insert(id);
                        deliverySequence.push_back(id);
                        orderMap.erase(id);
                    } else {
                        remaining.push_back(id);
                    }
                }
                cityToOrdersMap[cityId] = remaining;
            }
            currentCityId = cityId;
        }
    }

    return deliverySequence;
}

int main() {
    vector<Order> orders = {
        {1, 2}, {2, 4}, {3, 3}, {4, 5}
    };

    unordered_map<int, int> priority = {
        {1, 2}, {2, 5}, {3, 3}, {4, 4}
    };

    unordered_map<int, City> cityMap = {
        {1, {1, {{2, 1}, {3, 4}}}},
        {2, {2, {{1, 1}, {4, 2}}}},
        {3, {3, {{1, 4}, {4, 1}}}},
        {4, {4, {{2, 2}, {3, 1}, {5, 3}}}},
        {5, {5, {{4, 3}}}}
    };

    vector<int> result = PriorityBasedDelivery(orders, priority, cityMap, 1);
    for (int id : result) {
        cout << "Delivered Order ID: " << id << endl;
    }
    return 0;
}
